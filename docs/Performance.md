# Instaparse Performance Notes

In the instaparse tutorial, I make the claim that instaparse is performant without really defining what I mean.  I explained that I've spent a lot of time on optimization, without really specifying what I'm tring to optimize.  In this document, I'd like to elaborate on these issues, and talk a bit about how I see instaparse's role in the parser ecosystem.  Finally, I'll provide specific tips on how to get good performance from instaparse parsers.

## A bit of history

For decades, parsing has been considered a "solved problem", because there are well-known algorithms that can parse a stream of text blazingly fast, in a single linear pass, using minimal memory.  The catch is that these algorithms only apply to certain types of context-free grammars -- these classes of easily-parsed grammars go by names like LL(1) and LALR(1), acronyms describing the parsing technique that applies.  The good news is that most context-free grammars can, with some effort, be converted into the kind of format required by parsing algorithms.  Furthermore, if you are knowledgable about parsing algorithms and are the one constructing the language / data format to be parsed, you can intentionally constrain the syntax to ensure that it can easily be parsed.

If you can do that, great!  If there's already a parser written for the kind of data you're working with, even better!  However, the programming world is awash with ad hoc config files and data files that don't use an existing standard like XML or JSON.  Sometimes you find yourself needing to work with something that's a little too complex to tease apart just with regular expressions, yet hard to justify the time and energy it would take to study up on LL, LALR, etc. and learn how to parse the data within the constraints of tools using those parsing algorithms.

## The role of instaparse

That's where instaparse comes in.  Instaparse can handle arbitrary context-free grammars written using standard notation, so it's easy to apply it, even for a quickie one-time parsing task.

Shortly after the release of instaparse, there were a couple great testimonial blog posts about instaparse.  [This blog post by Brandon Harvey](http://walkwithoutrhythm.net/blog/2013/05/16/instaparse-parsing-with-clojure-is-the-new-black/) especially made my day, because it perfectly captured what I had hoped to achieve with instaparse.  

In his blog post, Brandon describes some cave data that he wanted to parse.  Ideally, he wanted to figure out how to get "from a big fat unwieldy string to a nice, regular tree-shaped data structure in 20 minutes or less."  The cave data is clearly structured and looks kind of like JSON, but it isn't quite JSON.

First, he tried using another Clojure parsing library (a rather excellent library provided you're working with a grammar that fits its constraints), but couldn't figure out how to express his grammar in a way that worked.  He got bogged down with a bunch of shift/reduce conflicts and other errors  that he didn't know how to interpret without understanding the underlying machinery.  Using instaparse, he expressed the grammar in the way that seemed most natural, and it worked.

This brings me to my first main point about performance:

*Instaparse aims to be more flexible than traditional parser libraries --- more tolerant of grammars that are ambiguous, require backtracking, or use a mixture of left and right recursion.*

To accomplish this, instaparse uses a fundamentally different algorithm than those found in traditional parser libraries, which achieve their speeds and performance guarantees by restricting lookahead and limiting backtracking.

## Specific performance goals

With that disclaimer in mind, here are the specifics of what I strive for:

+ For typical, real-world grammars, I want the running time to be linear with respect to the size of the input.  In other words, if you double the size of your text, it should take about twice as long to parse.  (Of course, I'm using Clojure data structures, so in practice, the running time is more like O(n * log32 n), but that's pretty close to linear.)
+ If your grammar is unambiguous and LL(1), the parser should be competitive with parsers generated by tools that *only* accept unambiguous LL(1) grammars (i.e., within some reasonable constant factor).
+ If you have a reasonable grammar, even one that isn't expressed in "just the right way", it should still have solid performance.
+ Performance should degrade gracefully as you incorporate more ambiguity and heavy backtracking into the grammar.

In some sense, instaparse is like Clojure itself.  We accept that Clojure is somewhat slower than writing directly in Java because we understand that Clojure offers us greater expressivity and immutable data structures that are competitive with, but not quite as fast as their mutable counterparts.  If we need more extreme performance, we know we can drop down to the Java level if absolutely necessary.  Similarly, the goal is for instaparse to have a performance profile that is similar to, but possibly a bit slower than its less flexible counterparts.  If you have truly high-performance needs, you should think about "dropping down to the Java level" and creating your parser with a tool like Antlr.

